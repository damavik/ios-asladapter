//
//  RCASLCapture.m
//  RCASLAdapter
//
//  Created by Vital Vinahradau on 3/16/16.
//

#import "RCASLCapture.h"
#include <asl.h>
#include <notify.h>
#include <notify_keys.h>
#include <sys/time.h>


@interface RCASLCapture()

@property (nonatomic, copy) RCLogMessage *previousMessage;

@end

@implementation RCASLCapture {
    int _notificationToken;
}

- (instancetype)init {
    if (self = [super init]) {
        _notificationToken = NOTIFY_TOKEN_INVALID;
        _logLevel = RCLogLevelAll;
    }
    
    return self;
}

- (void)startWithCallback:(void (^)(RCLogMessage *logMessage))callback {
    @autoreleasepool {
        _notificationToken = NOTIFY_TOKEN_INVALID;
        uint32_t status = notify_register_dispatch(kNotifyASLDBUpdate,
                                                   &_notificationToken,
                                                   dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(int token) {
                                                       [self processAslMessagesWithCallback:callback];
                                                   });
        
        if (status == NOTIFY_STATUS_OK) {
            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                [self processAslMessagesWithCallback:callback];
            });
        }
    }
}

- (void)stopWithCompletion:(nullable void (^)(void))completion {
    if (_notificationToken == NOTIFY_TOKEN_INVALID) {
        if (completion != nil) {
            completion();
        }
        return;
    }
    
    notify_cancel(_notificationToken);
    _notificationToken = NOTIFY_TOKEN_INVALID;
    
    if (completion != nil) {
        completion();
    }
}

#pragma mark Utils

- (RCLogFlag)levelFlagFromAslMessage:(aslmsg)msg {
    RCLogFlag flag = RCLogFlagError;
    
    int aslLogLevel = 0;
    const char *aslLevelString = asl_get(msg, ASL_KEY_LEVEL);
    if (aslLevelString != NULL) {
        aslLogLevel = atoi(aslLevelString);
    }
    
    switch (aslLogLevel) {
        case ASL_LEVEL_NOTICE:
        case ASL_LEVEL_WARNING:
        case ASL_LEVEL_INFO: { // Default NSLog level
            flag = RCLogFlagInfo;
            break;
        }
            
        case ASL_LEVEL_EMERG:
        case ASL_LEVEL_ALERT:
        case ASL_LEVEL_CRIT:
        case ASL_LEVEL_ERR: {
            flag = RCLogFlagError;
            break;
        }
            
        case ASL_LEVEL_DEBUG:
        default: {
            flag = RCLogFlagDebug;
            break;
        }
    }
    
    return flag;
}

- (NSDate *)timestampFromAslMessage:(aslmsg)msg {
    const char *secondsCString = asl_get(msg, ASL_KEY_TIME);
    const char *nanoCString = asl_get(msg, ASL_KEY_TIME_NSEC);
    
    NSTimeInterval seconds = secondsCString ? strtod(secondsCString, NULL) : [NSDate timeIntervalSinceReferenceDate] - NSTimeIntervalSince1970;
    NSTimeInterval nanoSeconds = nanoCString? strtod(nanoCString, NULL) : 0;
    NSTimeInterval totalSeconds = seconds + (nanoSeconds / 1e9);
    
    return [NSDate dateWithTimeIntervalSince1970:totalSeconds];
}

- (nullable RCLogMessage *)logMessageFromAslMessage:(aslmsg)msg {
    const char *messageString = asl_get(msg, ASL_KEY_MSG);
    if (messageString == NULL) {
        return nil;
    }
    
#ifdef DEBUG
    const char *targetFacility = [self.targetFacility UTF8String];
    if (targetFacility != NULL) {
        const char *facility = asl_get(msg, ASL_KEY_FACILITY);
        if (![@(facility) isEqualToString:self.targetFacility]) {
            return nil;
        }
    }
#endif
    
    RCLogFlag logLevelFlag = [self levelFlagFromAslMessage:msg];
    if (!(self.logLevel & logLevelFlag)) {
        return nil;
    }
    
    RCLogMessage *logMessage = [RCLogMessage new];
    logMessage.logLevel = logLevelFlag;
    logMessage.message = @(messageString);
    logMessage.timestamp = [self timestampFromAslMessage:msg];
    
    return logMessage;
}

- (void)processAslMessagesWithCallback:(void (^)(RCLogMessage *logMessage))callback {
    @autoreleasepool {
        static unsigned long long lastSeenID = 0;
        aslmsg query = asl_new(ASL_TYPE_QUERY);
        
        // Generated by currently running application only
        NSString *bundleId = NSBundle.mainBundle.infoDictionary[@"CFBundleName"];
        if (bundleId != nil) {
            asl_set_query(query,
                          ASL_KEY_SENDER,
                          [bundleId UTF8String],
                          ASL_QUERY_OP_EQUAL);
        }
        
        char stringValue[64];
        if (lastSeenID > 0) {
            snprintf(stringValue, sizeof stringValue, "%llu", lastSeenID);
            asl_set_query(query, ASL_KEY_MSG_ID, stringValue, ASL_QUERY_OP_GREATER | ASL_QUERY_OP_NUMERIC);
        } else {
            struct timeval timeval = { .tv_sec = 0 };
            gettimeofday(&timeval, NULL);
            unsigned long long startTime = timeval.tv_sec;
            
            snprintf(stringValue, sizeof stringValue, "%llu", startTime);
            asl_set_query(query, ASL_KEY_TIME, stringValue, ASL_QUERY_OP_GREATER_EQUAL | ASL_QUERY_OP_NUMERIC);
        }
        
        aslmsg msg = NULL;
        aslresponse response = asl_search(NULL, query);
        
        while ((msg = asl_next(response))) {
            RCLogMessage *logMessage = [self logMessageFromAslMessage:msg];
            
            if (logMessage != nil) {
                if (![logMessage isEqual:self.previousMessage]) {
                    callback(logMessage);
                }
                
                self.previousMessage = logMessage;
            }
            
            lastSeenID = atoll(asl_get(msg, ASL_KEY_MSG_ID));
            
            if (self->_notificationToken == NOTIFY_TOKEN_INVALID) {
                break;
            }
        }
        asl_release(response);
        asl_release(query);
    }
}

@end
